package config

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/BurntSushi/toml"
)

const TOMLConfigFileName = "config.toml"

// TOMLAgent is the TOML-level representation of an agent.
// Maps directly to [agents.*] tables in config.toml.
type TOMLAgent struct {
	Enabled     bool     `toml:"enabled"`
	Program     string   `toml:"program"`
	Model       string   `toml:"model,omitempty"`
	Temperature *float64 `toml:"temperature,omitempty"`
	Effort      string   `toml:"effort,omitempty"`
	Flags       []string `toml:"flags,omitempty"`
}

func (a TOMLAgent) toProfile() AgentProfile {
	return AgentProfile{
		Program:     a.Program,
		Model:       a.Model,
		Temperature: a.Temperature,
		Effort:      a.Effort,
		Enabled:     a.Enabled,
		Flags:       a.Flags,
	}
}

// TOMLUIConfig holds UI-specific settings from the [ui] TOML table.
type TOMLUIConfig struct {
	AnimateBanner bool `toml:"animate_banner"`
}

// TOMLConfig is the top-level TOML file structure.
type TOMLConfig struct {
	Phases map[string]string    `toml:"phases"`
	Agents map[string]TOMLAgent `toml:"agents"`
	UI     TOMLUIConfig         `toml:"ui"`
}

// TOMLConfigResult holds the parsed config in terms of internal types.
type TOMLConfigResult struct {
	Profiles      map[string]AgentProfile
	PhaseRoles    map[string]string
	AnimateBanner bool
}

// LoadTOMLConfigFrom reads and parses a TOML config file,
// returning the result mapped to internal types.
func LoadTOMLConfigFrom(path string) (*TOMLConfigResult, error) {
	var tc TOMLConfig
	if _, err := toml.DecodeFile(path, &tc); err != nil {
		return nil, fmt.Errorf("decode TOML config: %w", err)
	}

	result := &TOMLConfigResult{
		Profiles:      make(map[string]AgentProfile),
		PhaseRoles:    tc.Phases,
		AnimateBanner: tc.UI.AnimateBanner,
	}

	for name, agent := range tc.Agents {
		result.Profiles[name] = agent.toProfile()
	}

	return result, nil
}

// LoadTOMLConfig loads the TOML config from the default location (~/.config/kasmos/config.toml).
// Returns nil, nil if the file does not exist.
func LoadTOMLConfig() (*TOMLConfigResult, error) {
	configDir, err := GetConfigDir()
	if err != nil {
		return nil, err
	}
	path := filepath.Join(configDir, TOMLConfigFileName)

	if _, err := os.Stat(path); err != nil {
		if os.IsNotExist(err) {
			return nil, nil // no TOML config is valid
		}
		return nil, fmt.Errorf("stat TOML config: %w", err)
	}

	return LoadTOMLConfigFrom(path)
}

// SaveTOMLConfigTo writes a TOMLConfig to the given path.
func SaveTOMLConfigTo(tc *TOMLConfig, path string) (retErr error) {
	if err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {
		return fmt.Errorf("create config dir: %w", err)
	}

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("create config file: %w", err)
	}
	defer func() {
		if cerr := f.Close(); cerr != nil && retErr == nil {
			retErr = fmt.Errorf("close config file: %w", cerr)
		}
	}()

	if _, err := fmt.Fprintln(f, "# Generated by kas init"); err != nil {
		return err
	}
	if _, err := fmt.Fprintln(f); err != nil {
		return err
	}

	enc := toml.NewEncoder(f)
	if err := enc.Encode(tc); err != nil {
		return fmt.Errorf("encode TOML: %w", err)
	}
	return nil
}

// SaveTOMLConfig writes to the default location (~/.config/kasmos/config.toml).
func SaveTOMLConfig(tc *TOMLConfig) error {
	configDir, err := GetConfigDir()
	if err != nil {
		return err
	}
	return SaveTOMLConfigTo(tc, filepath.Join(configDir, TOMLConfigFileName))
}

// GetTOMLConfigPath returns the path to the TOML config file.
func GetTOMLConfigPath() (string, error) {
	configDir, err := GetConfigDir()
	if err != nil {
		return "", err
	}
	return filepath.Join(configDir, TOMLConfigFileName), nil
}
